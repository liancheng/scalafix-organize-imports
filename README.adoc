:latest-release: 0.3.1-RC1

ifdef::env-github[]
:caution-caption: :warning:
:warning-caption: :no_entry:
:tip-caption: :bulb:
endif::[]

= OrganizeImports
:icons: font
:sectnums:
:toc-placement!:
:toc-title:
:toc:
:toclevels: 2

image:https://github.com/liancheng/scalafix-organize-imports/workflows/Build/badge.svg[]
https://github.com/liancheng/scalafix-organize-imports/releases/latest[image:https://img.shields.io/github/v/tag/liancheng/scalafix-organize-imports[]]
https://github.com/liancheng/scalafix-organize-imports/blob/master/LICENSE[image:https://img.shields.io/github/license/liancheng/scalafix-organize-imports[]]
https://scala-steward.org[image:https://img.shields.io/badge/Scala_Steward-helping-blue.svg[]]
https://codecov.io/gh/liancheng/scalafix-organize-imports[image:https://img.shields.io/codecov/c/github/liancheng/scalafix-organize-imports[]]

toc::[]

`OrganizeImports` is a https://scalacenter.github.io[Scalafix] semantic rule that helps you to organize import statements.

== Getting started

Please refer to https://scalacenter.github.io/scalafix/docs/users/installation.html[the Scalafix documentation] for how to install Scalafix and invoking it in your build.

To try this rule in SBT console without updating your SBT build:

[source,subs="attributes+"]
----
sbt> scalafix dependency:OrganizeImports@com.github.liancheng:organize-imports:{latest-release}
----

To include this rule in your SBT build:

[source,scala,subs="attributes+"]
----
ThisBuild / scalafixDependencies += "com.github.liancheng" %% "organize-imports" % "{latest-release}"
----

[[remove-unused-warning]]
[WARNING]
====
Please do NOT use the Scalafix built-in `RemoveUnsed` rule together with `OrganizeImports` to remove unused imports. You may end up with broken code!

Scalafix rewrites source files by applying patches generated by invoked rules. Each rule generates a patch based on the _original_ text of the source files. Therefore, when two patches generated by different rules conflict with each other, Scalafix is not able to reconcile the conflicts, and may produce broken code. This is exactly what happens when `RemoveUnused` and `OrganizeImports` are used together, since both rules rewrite import statements.

By default, `OrganizeImports` already removes unused imports for you (see the <<remove-unused, `removeUnused`>> option). It locates unused imports via compilation diagnostics, which is exactly how `RemoveUnused` does it. This mechanism works well in most cases, unless there are new unused imports generated while organizing imports, which is possible when the <<expand-relative, `expandRelative`>> option is set to true. For now, the only reliable workaround for this edge case is to run Scalafix twice, once with `OrganizeImports`, and another with `RemoveUnused`.
====

== Configuration

=== Default configuration values

[source,hocon]
----
OrganizeImports {
  coalesceToWildcardImportThreshold = 2147483647 # Int.MaxValue
  expandRelative = false
  groupedImports = Explode
  groups = ["re:javax?\\.", "scala.", "*"]
  importSelectorsOrder = Ascii
  removeUnused = true
}
----

=== `coalesceToWildcardImportThreshold`

==== Description

When the number of imported names exceeds a certain threshold, coalesce them into a wildcard import. Renames and unimports are left untouched.

[CAUTION]
====
Having this feature in `OrganizeImports` is mostly for feature parity with the IntelliJ IDEA Scala import optimizer, but coalescing grouped import selectors into a wildcard import may introduce _compilation errors_! 

Here is an example to illustrate the risk. The following snippet compiles successfully:

[source,scala]
----
import scala.collection.immutable._
import scala.collection.mutable.{ArrayBuffer, Map, Set}

object Example {
  val m: Map[Int, Int] = ???
}
----
The type of `Example.m` above is not ambiguous because the mutable `Map` explicitly imported in the second import takes higher precedence than the immutable `Map` imported via wildcard in the first import.

However, if we coalesce the grouped importes in the second import statement into a wildcard, there will be a compilation error:
[source,scala]
----
import scala.collection.immutable._
import scala.collection.mutable._

object Example {
  val m: Map[Int, Int] = ???
}
----
This is because the type of `Example.m` becomes ambiguous now since both the mutable and immutable `Map` are imported via a wildcard and have the same precedence.
====

==== Value type

Integer

==== Default value

`Int.MaxValue`

Rationale:: Setting the default value to `Int.MaxValue` essentially disables this feature, since it can may cause correctness issues.

==== Example

Configuration:

[source,scala]
----
OrganizeImports {
  groupedImports = Keep
  coalesceToWildcardImportThreshold = 3
}
----

Before:

[source,scala]
----
import scala.collection.immutable.{Seq, Map, Vector, Set}
import scala.collection.immutable.{Seq, Map, Vector}
import scala.collection.immutable.{Seq, Map, Vector => Vec, Set, Stream}
import scala.collection.immutable.{Seq, Map, Vector => _, Set, Stream}
----

After:

[source,scala]
----
import scala.collection.immutable._
import scala.collection.immutable.{Map, Seq, Vector}
import scala.collection.immutable.{Vector => Vec, _}
import scala.collection.immutable.{Vector => _, _}
----

[[expand-relative]]
=== `expandRelative`

==== Description

Expand relative imports into fully-qualified one.

[CAUTION]
====
Expanding relative imports may introduce new unused imports. For instance, relative imports in the following snippet

[source,scala]
----
import scala.util
import util.control
import control.NonFatal
----

are expanded into

[source,scala]
----
import scala.util
import scala.util.control
import scala.util.control.NonFatal
----

If neither `scala.util` nor `scala.util.control` is referenced anywhere after the expansion, they become unused imports.

Unfortunately, these newly introduced unused imports cannot be removed by setting `removeUnused` to `true`. Please refer to the <<remove-unused, `removeUnused`>> option for more details.
====

==== Value type

Boolean

==== Default value

`false`

==== Example

Configuration:

[source,hocon]
----
OrganizeImports {
  expandRelative = true
  groups = ["re:javax?\\.", "scala.", "*"]
}
----

Before:

[source,scala]
----
import scala.util
import util.control
import control.NonFatal
import scala.collection.JavaConverters._
import java.time.Clock
import sun.misc.BASE64Encoder
import javax.annotation.Generated
import scala.concurrent.ExecutionContext
----

After:

[source,scala]
----
import java.time.Clock
import javax.annotation.Generated

import scala.collection.JavaConverters._
import scala.concurrent.ExecutionContext
import scala.util
import scala.util.control
import scala.util.control.NonFatal

import sun.misc.BASE64Encoder
----

=== `groupedImports`

==== Description

Configure how to handle grouped imports.

==== Value type

Enum: `Explode | Merge | Keep`

`Explode`:: Explode grouped imports into separate import statements.

`Merge`:: Merge imports sharing the same prefix into a single grouped import statement.

`Keep`:: Leave grouped imports and imports sharing the same prefix untouched.

==== Default value

`Explode`

==== Examples

`Explode`::
+
--
Configuration:

[source,hocon]
----
OrganizeImports.groupedImports = Explode
----

Before:

[source,scala]
----
import scala.collection.mutable.{ArrayBuffer, Buffer, StringBuilder}
----

After:

[source,scala]
----
import scala.collection.mutable.ArrayBuffer
import scala.collection.mutable.Buffer
import scala.collection.mutable.StringBuilder
----
--

`Merge`::
+
--
Configuration:

[source,hocon]
----
OrganizeImports.groupedImports = Merge
----

Before:

[source,scala]
----
import scala.collection.mutable.ArrayBuffer
import scala.collection.mutable.Buffer
import scala.collection.mutable.StringBuilder
----

After:

[source,scala]
----
import scala.collection.mutable.{ArrayBuffer, Buffer, StringBuilder}
----
--

[[groups]]
=== `groups`

==== Description

Defines import groups by prefix patterns. Only global imports are processed.

CAUTION: Comments living _between_ imports being processed will be _removed_.

All the imports matching the same prefix pattern are gathered into the same group and sorted by the order defined by the <<imports-order, `importsOrder`>> option.

[TIP]
====
`OrganizeImports` tries to match the longest prefix while grouping imports. For instance, the following configuration groups `scala.meta.` and `scala.` imports into different two groups properly:

[source,hocon]
----
OrganizeImports.groups = [
  "re:javax?\\."
  "scala."
  "scala.meta."
  "*"
]
----
====

Relative imports and _explicitly imported_ implicit names (what a tongue twister!) are moved to a separate group. This group always locates after all the other import groups, and imports within this group are always sorted by the original order they appear in the source file. This special handling is necessary because both relative imports and explicitly imported implicit names are order sensitive:

Relative imports::
+
--
For instance, sorting the following imports in alphabetical order introduces compilation errors:

[source,scala]
----
import scala.util
import util.control
import control.NonFatal
----
--

Explicitly imported implicit names::
+
--
This case is more subtle. The following snippet compiles correctly:
[source,scala]
----
package a

import c._
import b.i

object b { implicit def i = ??? }
object c { implicit def i = ??? }

class Imports {
  def f()(implicit i: Int) = ???
  def main() = f()
}
----
But if we reorder the two imports into:
[source,scala]
----
import b.i
import c._
----
The Scala compiler complians:
----
error: could not find implicit value for parameter i: Int
  def main() = f()
                ^
----
This could be a Scala compiler bug since https://scala-lang.org/files/archive/spec/2.13/02-identifiers-names-and-scopes.html[the Scala language specification] requires that explicitly imported names should always have higher precedence than names made available via a wildcard.

To avoid having such implicit imports appearing before any wildcard import that may introduce a conflicting implicit, they are always moved to the last import group.
--

==== Value type

An ordered list of import prefix pattern strings. A prefix pattern can be one of the following:

A plain-text pattern:: For instance, `"scala."` is a plain-text pattern that matches imports referring the `scala` package. Please note that the trailing dot is necessary, otherwise you may have `scalafix` and `scala` imports in the same group, which is not what you want in most cases.

A regular expression pattern:: A regular expression pattern starts with `re:`. For instance, `"re:javax?\\."` is a regular expression pattern that matches both `java` and `javax` packages.

The wildcard pattern::
+
--
The wildcard pattern, `"*"`, defines the wildcard group, which matches all fully-qualified imports not belonging to any other groups. It can be omitted when it's the last group. So the following two configurations are equivalent:

[source,hocon]
----
OrganizeImports.groups = ["re:javax?\\.", "scala.", "*"]
OrganizeImports.groups = ["re:javax?\\.", "scala."]
----

==== Default value

[source,hocon]
----
[
  "re:javax?\\."
  "scala."
  "*"
]
----
--

==== Examples

Fully-qualified imports only::
+
--
Configuration:

[source,hocon]
----
OrganizeImports.groups = ["re:javax?\\.", "scala.", "*"]
----

Before:

[source,scala]
----
import scala.collection.JavaConverters._
import java.time.Clock
import sun.misc.BASE64Encoder
import javax.annotation.Generated
import scala.concurrent.ExecutionContext
----

After:

[source,scala]
----
import java.time.Clock
import javax.annotation.Generated

import scala.collection.JavaConverters._
import scala.concurrent.ExecutionContext

import sun.misc.BASE64Encoder
----
--

With relative imports::
+
--
Configuration:

[source,hocon]
----
OrganizeImports.groups = ["re:javax?\\.", "scala.", "*"]
----

Before:

[source,scala]
----
import scala.util
import util.control
import control.NonFatal
import scala.collection.JavaConverters._
import java.time.Clock
import sun.misc.BASE64Encoder
import javax.annotation.Generated
import scala.concurrent.ExecutionContext
----

After:

[source,scala]
----
import java.time.Clock
import javax.annotation.Generated

import scala.collection.JavaConverters._
import scala.concurrent.ExecutionContext
import scala.util

import sun.misc.BASE64Encoder

import util.control
import control.NonFatal
----
--

With relative imports and an explicitly imported implicit name::
+
--
Configuration:

[source,hocon]
----
OrganizeImports.groups = ["re:javax?\\.", "scala.", "*"]
----

Before:

[source,scala]
----
import scala.util
import util.control
import control.NonFatal
import scala.collection.JavaConverters._
import java.time.Clock
import sun.misc.BASE64Encoder
import javax.annotation.Generated
import scala.concurrent.ExecutionContext.Implicits.global
----

After:

[source,scala]
----
import java.time.Clock
import javax.annotation.Generated

import scala.collection.JavaConverters._
import scala.util

import sun.misc.BASE64Encoder

import util.control
import control.NonFatal
import scala.concurrent.ExecutionContext.Implicits.global
----
--

Regular expression::
+
--
Defining import groups using regular expressions can be quite flexible. For instance, the `scala.meta` package is not part of the Scala standard library (yet), but the default groups defined in the `OrganizeImports.groups` option move imports from this package into the `scala.` group. The following example illustrates how to move them into the wildcard group using regular expression.

Configuration:
[source,hocon]
----
OrganizeImports.groups = [
  "re:javax?\\."
  "re:scala.(?!meta\\.)"
  "*"
]
----

Before:
[source,scala]
----
import scala.collection.JavaConverters._
import java.time.Clock
import sun.misc.BASE64Encoder
import scala.meta.Tree
import javax.annotation.Generated
import scala.concurrent.ExecutionContext
import scala.meta.Import
import scala.meta.Pkg
----

After:
[source,scala]
----
import java.time.Clock
import javax.annotation.Generated

import scala.collection.JavaConverters._
import scala.concurrent.ExecutionContext

import scala.meta.Import
import scala.meta.Pkg
import scala.meta.Tree
import sun.misc.BASE64Encoder
----
--

=== `importSelectorsOrder`

==== Description

Specifies the order of grouped import selectors within a single import expression.

==== Value type

Enum: `Ascii | SymbolsFirst | Keep`

`Ascii`:: Sort import selectors by ASCII codes, equivalent to the https://scalameta.org/scalafmt/docs/configuration.html#asciisortimports[`AsciiSortImports`] rewriting rule in Scalafmt.

`SymbolsFirst`:: Sort import selectors by the groups: symbols, lower-case, upper-case, equivalent to the https://scalameta.org/scalafmt/docs/configuration.html#sortimports[`SortImports`] rewriting rule in Scalafmt.

`Keep`:: Keep the original order.

==== Default value

`Ascii`

==== Examples

`Ascii`::
+
--
Configuration:

[source,hocon]
----
OrganizeImports {
  groupedImports = Keep
  importSelectorsOrder = Ascii
}
----

Before:

[source,scala]
----
import foo.{~>, `symbol`, bar, Random}
----

After:

[source,scala]
----
import foo.{Random, `symbol`, bar, ~>}
----
--

`SymbolsFirst`::
+
--
Configuration:

[source,hocon]
----
OrganizeImports {
  groupedImports = Keep
  importSelectorsOrder = SymbolsFirst
}
----

Before:

[source,scala]
----
import foo.{Random, `symbol`, bar, ~>}
----

After:

[source,scala]
----
import foo.{~>, `symbol`, bar, Random}
----
--

[[imports-order]]
=== `importsOrder`

==== Description

Specifies the order of import statements within import groups defined by the <<groups, `OrganizeImports.groups`>> option.

==== Value type

Enum: `Ascii | SymbolsFirst | Keep`

`Ascii`:: Sort import statements by ASCII codes. This is the default sorting order that the IntelliJ IDEA Scala import optimizer picks ("lexicographically" option).

`SymbolsFirst`:: Put wildcard imports and grouped imports with braces first, otherwise same as `Ascii`. This replicates IntelliJ IDEA Scala's "scalastyle consistent" option.

`Keep`:: Keep the original order.

==== Default value

`Ascii`

==== Examples

`Ascii`::
+
--
Configuration:

[source,hocon]
----
OrganizeImports {
  groupedImports = Keep
  importsOrder = Ascii
}
----

Before:

[source,scala]
----
import scala.concurrent._
import scala.concurrent.{Future, Promise}
import scala.concurrent.ExecutionContext.Implicits._
import scala.concurrent.duration
----

After:

[source,scala]
----
import scala.concurrent.ExecutionContext.Implicits._
import scala.concurrent._
import scala.concurrent.duration
import scala.concurrent.{Promise, Future}
----
--

`SymbolsFirst`::
+
--
Configuration:

[source,hocon]
----
OrganizeImports {
  groupedImports = Keep
  importsOrder = SymbolsFirst
}
----

Before:

[source,scala]
----
import scala.concurrent.ExecutionContext.Implicits._
import scala.concurrent._
import scala.concurrent.duration
import scala.concurrent.{Promise, Future}
----

After:

[source,scala]
----
import scala.concurrent._
import scala.concurrent.{Future, Promise}
import scala.concurrent.ExecutionContext.Implicits._
import scala.concurrent.duration
----
--

[[remove-unused]]
=== `removeUnused`

==== Description

Remove unused imports.

[CAUTION]
====
As mentioned in the <<remove-unused-warning, Getting started>> section, the `removeUnused` option doesn't play perfectly with the `expandRelative` option. Setting `expandRelative` to `true` might introduce new unused imports (see <<expand-relative, `expandRelative`>>). These newly introduced unused imports cannot be removed by setting `removeUnused` to `true`. This is because unused imports are identified using Scala compilation diagnostics information, and the compilation phase happens before Scalafix rules get applied.
====

==== Value type

Boolean

==== Default value

`true`

==== Example

Configuration:

[source,hocon]
----
OrganizeImports {
  groups = ["javax?\\.", "scala.", "*"]
  removeUnused = true
}
----

Before:

[source,scala]
----
import scala.collection.mutable.{Buffer, ArrayBuffer}
import java.time.Clock
import java.lang.{Long => JLong, Double => JDouble}

object RemoveUnused {
  val buffer: ArrayBuffer[Int] = ArrayBuffer.empty[Int]
  val long: JLong = JLong.parseLong("0")
}
----

After:

[source,scala]
----
import java.lang.{Long => JLong}

import scala.collection.mutable.ArrayBuffer

object RemoveUnused {
  val buffer: ArrayBuffer[Int] = ArrayBuffer.empty[Int]
  val long: JLong = JLong.parseLong("0")
}
----
